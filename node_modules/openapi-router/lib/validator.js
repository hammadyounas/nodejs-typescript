"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jsonschema_1 = require("jsonschema");
class Validator {
    constructor(operationId, spec, options) {
        this.spec = spec;
        this.operation = getOperation(operationId, spec);
        this.parameters = getParameters(this.operation, spec);
        this.jsonValidator = new jsonschema_1.Validator();
        this.jsonValidator.addSchema(spec, '/');
        this.ignoreInvalidHeaders = options && !!options.ignoreInvalidHeaders;
        this.ignoreMissingHeaders = options && !!options.ignoreMissingHeaders;
        this.ignoreInvalidBody = options && !!options.ignoreInvalidBody;
        this.ignoreInvalidStatus = options && !!options.ignoreInvalidStatus;
    }
    validateRequest(values) {
        const result = {
            errors: [],
            isValid: true,
            params: {},
        };
        if (!this.parameters.length)
            return result;
        this.parameters.forEach(parameter => {
            let value = getValueOrDefault(values[parameter.name], parameter);
            if (typeof value !== 'undefined') {
                value = preCast(value, parameter);
                const validatorResult = this.validateValue(value, parameter.in === 'body' ? parameter.schema : parameter);
                if (validatorResult && !validatorResult.errors.length) {
                    value = postCast(value, parameter.in === 'body' ? parameter.schema : parameter);
                }
                result.params[parameter.name] = value;
                if (validatorResult.errors.length > 0) {
                    result.isValid = false;
                    result.errors.push({
                        parameter: parameter.name,
                        notFound: false,
                        notImplemented: false,
                        notAllowed: false,
                        errors: validatorResult.errors,
                    });
                }
            }
            else if (parameter.required) {
                result.isValid = false;
                result.errors.push({
                    parameter: parameter.name,
                    location: parameter.in,
                    notFound: true,
                    notImplemented: false,
                    notAllowed: false,
                });
            }
        });
        return result;
    }
    validateResponse(res, bodyArgs) {
        const response = this.getResponse(res.statusCode);
        if (response) {
            // Route found
            const headers = res.getHeaders();
            const headerDefinitions = response.headers || {};
            const contentType = parseContentType(headers['content-type']);
            const mimeType = contentType.mimeType;
            const encoding = (contentType.charset || '').replace('-', '');
            const data = Object.keys(bodyArgs)
                .map(key => bodyArgs[key])
                .filter(x => x)[0];
            const body = data ? parseBodyData(mimeType, encoding, data) : undefined;
            const headerErrors = Object.keys(headerDefinitions)
                .map(name => ({
                name,
                headerDefinition: headerDefinitions[name],
            }))
                .map(header => ({
                name: header.name,
                values: Array.isArray(headers[header.name])
                    ? headers[header.name]
                    : [headers[header.name]],
                headerDefinition: header.headerDefinition,
            }))
                .reduce((array, item) => {
                return array.concat(item.values.map(value => ({
                    name: item.name,
                    value: preCast(value, item.headerDefinition),
                    spec: item.headerDefinition,
                })));
            }, [])
                .map(header => this.validateValue(header.value, header.spec).errors.map(x => ({
                type: 'INVALID_HEADER',
                name: header.name,
                value: header.value,
                error: x,
            })))
                .reduce((a, b) => a.concat(b), []);
            const missingHeaders = Object.keys(headerDefinitions)
                .filter(key => !headers[key])
                .map(key => ({
                type: 'MISSING_HEADER',
                name: key,
            }));
            const bodyErrors = (response.schema
                ? this.validateValue(preCast(body, response.schema), response.schema)
                    .errors
                : []).map(error => ({
                type: 'INVALID_BODY',
                error,
            }));
            const errors = [
                this.ignoreInvalidHeaders ? [] : headerErrors,
                this.ignoreMissingHeaders ? [] : missingHeaders,
                this.ignoreInvalidBody ? [] : bodyErrors,
            ].reduce((a, b) => a.concat(b), []);
            return {
                errors,
                isValid: !errors.length,
            };
        }
        else if (!this.ignoreInvalidStatus) {
            return {
                errors: [
                    {
                        type: 'INVALID_STATUS',
                        value: res.statusCode,
                    },
                ],
                isValid: false,
            };
        }
        else {
            return { errors: [], isValid: true };
        }
    }
    get ignoreResponseErrors() {
        return (this.ignoreInvalidBody &&
            this.ignoreInvalidHeaders &&
            this.ignoreInvalidStatus &&
            this.ignoreMissingHeaders);
    }
    validateValue(value, parameterSchema) {
        return this.jsonValidator.validate(typeof value === 'undefined' ? null : value, parameterSchema);
    }
    getResponse(statusCode) {
        const response = this.operation.responses[`${statusCode}`] ||
            this.operation.responses.default;
        return response && isReference(response)
            ? resolveJsonPointer(response.$ref, this.spec)
            : response;
    }
}
exports.Validator = Validator;
// TODO: consider using a library for this
function resolveJsonPointer(jpath, object) {
    return jpath
        .split('/')
        .reduce((obj, segment) => (segment === '#' ? object : (obj || {})[segment]), object);
}
function getValueOrDefault(value, parameter) {
    return typeof value === 'undefined' &&
        !parameter.required &&
        parameter.in !== 'body'
        ? parameter.default
        : value;
}
// TODO: consider reusing body-parser logic
function parseBodyData(mimeType, encoding, data) {
    const decoded = data instanceof Buffer && encoding ? data.toString(encoding) : data;
    return mimeType === 'application/json' ? JSON.parse(decoded) : decoded;
}
function parseContentType(contentType) {
    if (!contentType) {
        return {};
    }
    const list = contentType.split('; ');
    const mimeType = list.shift();
    return list.reduce((obj, item) => {
        const x = item.split('=');
        obj[x[0]] = x[1];
        return obj;
    }, { mimeType });
}
/** Casts raw values from the request before they are validated */
function preCast(value, definition) {
    if (isParameter(definition) && definition.in === 'body')
        return value;
    let typePrimitive;
    if (Array.isArray(definition.type)) {
        typePrimitive = definition.type[0];
        console.warn(`Found type array. Defaulting to first type '${typePrimitive}'. See https://github.com/skonves/openapi-router/issues/9`);
    }
    else {
        typePrimitive = definition.type;
    }
    switch (typePrimitive) {
        case 'array': {
            let values;
            switch (definition.collectionFormat) {
                case 'ssv':
                    values = value.split(' ');
                    break;
                case 'tsv':
                    values = value.split('\t');
                    break;
                case 'pipes':
                    values = value.split('|');
                    break;
                case 'csv':
                default:
                    if (Array.isArray(value)) {
                        values = value;
                    }
                    else if (value.split) {
                        values = value.split(',');
                    }
                    else {
                        values = value;
                    }
                    break;
            }
            return values.map
                ? values.map(v => {
                    return preCast(v, definition.items);
                })
                : values;
        }
        case 'boolean': {
            if (typeof value === 'string') {
                return value.toLowerCase() === 'true' || value.toLowerCase() === 'false'
                    ? value.toLowerCase() === 'true'
                    : value;
            }
            else {
                return value;
            }
        }
        case 'integer': {
            const result = Number(value);
            return Number.isInteger(result) ? result : value;
        }
        case 'number': {
            const result = Number(value);
            return Number.isNaN(result) ? value : result;
        }
        case 'object': {
            try {
                return JSON.parse(value);
            }
            catch (ex) {
                return value;
            }
        }
        default: {
            return value;
        }
    }
}
/** Casts values AFTER validated to support string formats */
function postCast(value, definition) {
    const type = definition.type;
    const format = definition.format;
    if (type === 'string' && (format === 'date' || format === 'date-time')) {
        return new Date(value);
    }
    else {
        return value;
    }
}
function getOperation(operationId, spec) {
    return Object.keys(spec.paths)
        .map(path => Object.keys(spec.paths[path]).map(verb => spec.paths[path][verb]))
        .reduce((a, b) => a.concat(b), [])
        .find(operation => operation.operationId === operationId);
}
function getParameters(operation, spec) {
    if (operation && operation.parameters) {
        return operation.parameters.map((parameter, i) => {
            if (isReference(parameter) &&
                parameter.$ref.startsWith('#/parameters/')) {
                return spec.parameters[parameter.$ref.substr('#/parameters/'.length)];
            }
            else {
                return parameter;
            }
        });
    }
    else {
        return [];
    }
}
function isReference(value) {
    return value.$ref !== undefined;
}
function isParameter(value) {
    return value.name !== undefined;
}
//# sourceMappingURL=validator.js.map