"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const validator_1 = require("./validator");
const express_utility_1 = require("./express-utility");
class Router {
    constructor(spec, app, options) {
        this.spec = spec;
        this.app = app;
        this.options = options;
        this.handledPaths = new Set();
        this.operations = Object.keys(spec.paths)
            .map(path => {
            const pathItem = spec.paths[path];
            return Object.keys(pathItem).map(verb => {
                const operation = pathItem[verb];
                return {
                    id: operation.operationId,
                    verb,
                    path: getExpressPath(path),
                    operation,
                };
            });
        })
            .reduce((a, b) => a.concat(b), [])
            .filter(op => op.id);
    }
    /** Adds a route handler for the specified OpenAPI operation */
    use(operationId, handler) {
        const validator = new validator_1.Validator(operationId, this.spec, this.options);
        const operation = this.operations.find(op => op.id === operationId);
        if (!operation) {
            throw new Error(`Operation with ID '${operationId}' is not defined.`);
        }
        if (this.app[operation.verb]) {
            this.app[operation.verb](operation.path, (req, res, next) => {
                const values = express_utility_1.getValuesFromRequest(req, validator.parameters);
                req.openapi = validator.validateRequest(values);
                if (req.openapi.isValid) {
                    if (!validator.ignoreResponseErrors) {
                        const fn = res.end;
                        res.end = function () {
                            if (res.openapi || res.statusCode === 304) {
                                fn.apply(res, arguments);
                            }
                            else if (!res.openapi) {
                                res.openapi = validator.validateResponse(res, arguments);
                                if (res.openapi.isValid) {
                                    fn.apply(res, arguments);
                                }
                                else {
                                    next({
                                        code: types_1.OPENAPI_ERRORS,
                                        scope: types_1.ErrorScope.response,
                                    });
                                }
                            }
                        };
                    }
                    return handler(req, res, next);
                }
                else {
                    return next({
                        code: types_1.OPENAPI_ERRORS,
                        scope: types_1.ErrorScope.request,
                    });
                }
            });
            this.handledPaths.add(operation.path);
        }
        else {
            console.warn(`WARNING! Express cannot handle method ${operation.verb.toUpperCase()}`);
        }
    }
    /** Adds handlers for un-implemented operations, unsupported HTTP methods, as well as a final 404 catch-all */
    addCatchAllRoutes() {
        this.operations
            .filter(op => !this.handledPaths.has(op.path))
            .forEach(op => {
            console.warn(`WARNING! operation ${op.id} (${op.verb.toUpperCase()} ${op.path}) is unhandled`);
            this.app[op.verb](op.path, (req, res, next) => {
                req.openapi = req.openapi || {
                    errors: [],
                    isValid: false,
                    params: {},
                };
                req.openapi.errors.push({
                    notFound: false,
                    notImplemented: true,
                    notAllowed: false,
                });
                next({ code: types_1.OPENAPI_ERRORS, scope: types_1.ErrorScope.request });
            });
        });
        const paths = new Set(this.operations.map(op => op.path));
        paths.forEach(path => {
            this.app.all(path, (req, res, next) => {
                req.openapi = req.openapi || {
                    errors: [],
                    isValid: false,
                    params: {},
                };
                req.openapi.errors.push({
                    notFound: false,
                    notImplemented: false,
                    notAllowed: true,
                });
                next({ code: types_1.OPENAPI_ERRORS, scope: types_1.ErrorScope.request });
            });
        });
        this.app.all('*', (req, res, next) => {
            req.openapi = req.openapi || {
                errors: [],
                isValid: false,
                params: {},
            };
            req.openapi.errors.push({
                notFound: true,
                notImplemented: false,
                notAllowed: false,
            });
            next({ code: types_1.OPENAPI_ERRORS, scope: types_1.ErrorScope.request });
        });
    }
}
exports.Router = Router;
function getExpressPath(swaggerPath, basePath) {
    let expressPath = swaggerPath;
    while (expressPath.indexOf('{') > -1) {
        expressPath = expressPath.replace('{', ':').replace('}', '');
    }
    if (!expressPath.startsWith(basePath || '')) {
        throw new Error('Operation path is not located within base path');
    }
    return expressPath.substring((basePath || '').length);
}
//# sourceMappingURL=router.js.map